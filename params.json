{"name":"Utility-structure-exchange-format","tagline":"The schema definitions to enable the exchange of structure definitions among utilities ","body":"Utility Structure Exchange Format\r\n===================================\r\n\r\n![USEF](https://raw.githubusercontent.com/usmaw/utility-structure-exchange-format/master/resources/images/USEF_Logo.jpg)\r\n\r\nThis project provides the schema definitions to enable the exchange of structure definitions among different utility companies wishing to share the information in a generic manner. \r\n\r\nOverview\r\n----------\r\n\r\nCurrently the standard is a JSON based schema definition.  JSON was chosen because of its simplicity and ubiquitiy.  It is very readable and can be constructured with nothing more than a text editor.  This allows for the standard to be truely platform agnostic.\r\n\r\n### Design Philosphy\r\n\r\n1. Exchange file content should be human readable.\r\n1. The definition files should be as self documenting as possible.\r\n\r\n### Concepts\r\n\r\n1. If you are not familiar with JSON.  Try this short [tutorial](http://www.w3schools.com/json/default.asp).\r\n\r\nHow to Contribute\r\n------------------\r\n\r\nWe will be using the \"fork and pull\" workflow, github has excellent [documentataion](https://help.github.com/articles/using-pull-requests/) on the this process of doing public collaboration.    We will be using method here.\r\n\r\nIn general any pull request will be reviewed for following criteria:\r\n\r\n1. Constancy with the rest of the standard - Is the variable naming and structure similar to the rest of the schema?  \r\n2. General usefulness of the feature - Is it of general use to the industry or specific to a particular vendor?\r\n3. Documention provided - Are the relevant readme's and descriptions provided for user clarity?\r\n4. Testing - has the appropriate test cases been provided to ensure expected behavior.\r\n\r\nValidation\r\n===========\r\n\r\nCommand Line\r\n------------\r\n\r\nWe include a command line validator to validate against any of our included schemas. To run the command, use the validateJson gradle task\r\n\r\n    gradlew :validateJson -Pschema=/path/to/schema -PjsonFile=/path/to/json\r\n    schema - path to schema starting from resources. eg. /v1/schema/spidacalc/calc/structure.schema\r\n    json - json file to be validated.\r\n\r\nFor example, to validate the \"one of everything\" structure example, from the schema directory you would type:\r\n\r\n    gradlew :validateJson -Pschema=/v1/schema/structure/structure.schema -PjsonFile=resources/v1/examples/designs/one_of_everything.json\r\n\r\nThe tool uses the included Validator java class.\r\n\r\nExternal\r\n---------\r\n\r\nIf you are in need of actually validating some JSON data against the schema there several options depending on your language.  The one we use in our tests is the excellent library by [fge](https://github.com/fge/json-schema-validator).  It gives very good validation errors and also does all the references for you, so there is no need to load all the linked schema.  You will also notice in our tests we use a namespace of a file system.  This could be any location you put the file, you could even use a \"resource:/\" uri for referencing in a jar.\r\n\r\nAnother lightwight option is the javascript based validator located here http://geraintluff.github.io/tv4/\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}